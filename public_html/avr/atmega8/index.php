<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="../../css/index.css"/>
<link rel="stylesheet" type="text/css" href="../../css/childFrame.css"/>
<script src="../../js/childFrame.js"></script>
<title>AVR Series</title>
</head>

<body>
<header class="header">

<div class="hpart1">
 <a href="http://sembedded.net">SEmbedded Web</a>
</div>
<div class="dropdown">
  <button class="dropbtn">8051 Series</button>
  <div class="dropdown-content">
    <a href="../../8051/at89c51">AT89C51</a>
    <a href="../../8051/at89s51/">AT89S51</a>
    <a href="../../8051/sst89rdxx/">SST89RDxxx</a>

  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">AVR Series</button>
  <div class="dropdown-content">
    <a href="../atmega8/">ATmega8</a>
    <a href="../atmega16/">ATmega16</a>
    <a href="../atmega32/">ATmega32</a>
    <a href="../atmega128/">ATmega128</a>
    <a href="../atmega328p/">ATmega328p</a>
  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">PIC Series</button>
  <div class="dropdown-content">
    <a href="../../pic/pic12fxx/">PIC12Fxx</a>
    <a href="../../pic/pic16fxx/">PIC16Fxx</a>
    <a href="../../pic/pic18fxx/">PIC18Fxx</a>
    <a href="../../pic/pic24fjxx/">PIC24fjxxx</a>
    <a href="../../pic/pic32Mxxx/">PIC32MXxxx</a>
    <a href="../../pic/pic32_ds/">PIC_ds32</a>
  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">ARM Series</button>
  <div class="dropdown-content">
    <a href="../../arm/lpc2124/">LPC2124</a>
    <a href="../../arm/lpc2129/">LPC2129</a>
    <a href="../../arm/lpc2138/">LPC2138</a>
    <a href="../../arm/lpc2148/">LPC2148</a>
    <a href="../../arm/arm-cortexM0/">ARM-Cortex M0</a>
  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">FreeRTOS</button>
  <div class="dropdown-content">
    <a href="http://sembedded.net">LPC2124</a>
    <a href="#">LPC2148</a>
    <a href="#">PIC32</a>
  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">Linux</button>
  <div class="dropdown-content">
    <a href="http://sembedded.net">Shell Scripting</a>
    <a href="#">Process</a>
    <a href="#">MultiThreading</a>
    <a href="#">MUTEX</a>
    <a href="#">GUI with QT</a>
    <a href="#">Socket</a>
    <a href="#">Device Drivers</a>
  </div>
</div>

<div class="dropdown">
  <button class="dropbtn">Contact</button>
  <div class="dropdown-content">
    <a href="http://sembedded.net">Mail-Me</a>
    <a href="#">About Us</a>
  </div>
</div>
<!--<div class="hpart2">
      <a href="../8051"> 8051 Series  </a>
      <a href="../avr">  Avr Series   </a>
      <a href="../pic/"> Pic Series   </a>
      <a href="../arm/"> Arm Series   </a>
      <a href="uc.php">  Rtos         </a>
      <a href="uc.php">  Linux        </a>
      <a href="uc.php">  Contact Us   </a>
</div>-->
</header>
<div class="hr1"></div>
<!-- ********************************************** header END ****************************************** -->
<div class="Container1">
  <div class="Container1-Header">  <p><a style="text-decoration: none; color: #fff;"href="../">Home</a></p>  </div>
   <div class="Container1-List">
    		<ul class="list1">
          <li><a  id="defaultOpen" class="tablinks" href="#" onClick="openCity(event,'Intro',this)">Introduction</a></li><br/>
        		<li><a id="tab2" class="tablinks" href="#" onClick="openCity(event,'Basic',this)">Basics</a></li><br/>
        		<li><a id="tab3" class="tablinks" href="#" onClick="openCity(event,'Soft',this)">Software</a></li><br/>
        		<li><a id="tab4" class="tablinks" href="#" onClick="openCity(event,'Doc',this)">Documents</a></li><br/>
        		<li><a id="tab5" class="tablinks"href="#" onClick="openCity(event,'Code',this)">Codes</a></li><br/>
    		</ul>
   </div>
</div>

<div id="Intro" class="Container2">
  <div class="Container2-Header"> <p>ATmega8 - Introduction</p>  </div>
   <div class="Container2-text">
    		<p class="C1p1">In 1996, AVR Microcontroller was produced by the “Atmel Corporation”. The Microcontroller includes the Harvard architecture that works rapidly with the RISC. The features of this Microcontroller include different features compared with other like :
    		<br/><br/> <i>Sleep modes-6</i>
    		<br/> <i> Inbuilt ADC (analog to digital converter)</i>
    		<br/> <i> Internal oscillator and serial data communication</i>
    		<br/> <i> Performs the instructions in a single execution cycle. </i>
    		<br/><br/>
    		These Microcontroller were very fast and they utilize low power to work in different power saving modes. There are different configurations of AVR microcontrollers are available to perform various operations like <b>8-bit, 16-bit, and 32-bit</b>. <br/><br/>Please refer the below link for; Types of AVR Microcontroller
    		<br/><br/>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- main_page -->
        <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-8795837294797076"
        data-ad-slot="7076115916"
        data-ad-format="auto"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        AVR microcontrollers are available in three different categories such as TinyAVR, MegaAVR, and XmegaAVR

       <br/><br/><i>The Tiny AVR microcontroller is very small in size and used in many simple applications</i>
       <br/><i>Mega AVR microcontroller is very famous due to a large number of integrated components, good memory, and used in modern to multiple applications</i>
       <br/><i>The Xmega AVR microcontroller is applied in difficult applications, which require high speed and huge program memory.</i>
    	 <br/><br/><img style="margin:20px 0px 0px 40%; " src="../../images/Atmega8-Microcontroller.jpg"/>
    	 <br/><br/>
       <b>General Features</b>
       <br/>
       <br/><i> Advanced RISC Architecture</i>
       <br/><i> 130 Powerful Instructions – Most Single-clock Cycle Execution.</i>
       <br/><i> 32 × 8 General Purpose Working Registers</i>
       <br/><i> Fully Static Operation</i>
       <br/><i> Up to 16MIPS Throughput at 16MHz</i>
       <br/><i> On-chip 2-cycle Multiplier</i>
       <br/><i> High Endurance Non-volatile M</i>
       <br/><i> 8Kbytes of In-System Self-programmable Flash program memory</i>
       <br/><i> 512Bytes EEPROM</i>
       <br/><br/>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- ad2 -->
        <ins class="adsbygoogle"
        style="display:inline-block;width:728px;height:90px"
        data-ad-client="ca-pub-8795837294797076"
        data-ad-slot="9256197016"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        <br/>
        <br/><i> 1Kbyte Internal SRAM</i>
        <br/><i> Write/Erase Cycles: 10,000 Flash/100,000 EEPROM</i>
        <br/><i> Data retention: 20 years at 85°C/100 years at 25°C(1)</i>
        <br/><i> Optional Boot Code Section with Independent Lock Bits</i>
        <br/><i> In-System Programming by On-chip Boot Program</i>
        <br/><i> True Read-While-Write Operation</i>
        <br/><i> Programming Lock for Software Security</i>
        <br/><br/>
        </p>
    </div>
  </div>

<div id="Basic" class="Container2">
      <div class="Container2-Header"> <p>ATmega8 - Basic</p>  </div>
      <div class="Container2-text">
        <img src="../../images/atmega8.png"/>
           <p class="C1p1">
              <b>Pin Descriptions</b>

              <br/><br/><b>VCC : </b>Digital supply voltage:

              <br/><br/><b>GND : </b>Ground

              <br/><br/><b>Port B (PB7..PB0)XTAL1/XTAL2/TOSC1/TOSC2 : </b>
              <br/>Port B is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The
              Port B output buffers have symmetrical drive characteristics with both high sink and source
              capability. As inputs, Port B pins that are externally pulled low will source current if the pull-up
              resistors are activated. The Port B pins are tri-stated when a reset condition becomes active,
              even if the clock is not running.<br/><br/>
              Depending on the clock selection fuse settings, PB6 can be used as input to the inverting Oscillator
              amplifier and input to the internal clock operating circuit.<br/><br/>
              Depending on the clock selection fuse settings, PB7 can be used as output from the inverting
              Oscillator amplifier.<br/><br/>
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
              <!-- ad2 -->
              <ins class="adsbygoogle"
               style="display:inline-block;width:728px;height:90px"
               data-ad-client="ca-pub-8795837294797076"
               data-ad-slot="9256197016"></ins>
              <script>
              (adsbygoogle = window.adsbygoogle || []).push({});
              </script><br/><br/>
              If the Internal Calibrated RC Oscillator is used as chip clock source, PB7..6 is used as TOSC2..1
              input for the Asynchronous Timer/Counter2 if the AS2 bit in ASSR is set.
              <br/><br/><b>Port C (PC5..PC0): </b></br>
              Port C is an 7-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The
              Port C output buffers have symmetrical drive characteristics with both high sink and source
              capability. As inputs, Port C pins that are externally pulled low will source current if the pull-up
              resistors are activated. The Port C pins are tri-stated when a reset condition becomes active,
              even if the clock is not running.
              <br/><br/><b>PC6/RESET : </b>
              <br/> If the RSTDISBL Fuse is programmed, PC6 is used as an I/O pin. Note that the electrical characteristics
                    of PC6 differ from those of the other pins of Port C.
                    If the RSTDISBL Fuse is unprogrammed, PC6 is used as a Reset input. A low level on this pin
                    for longer than the minimum pulse length will generate a Reset, even if the clock is not running.
             <br/><br/><b>Port D (PD7..PD0) : </b>
             <br/>  Port D is an 8-bit bi-directional I/O port with internal pull-up resistors (selected for each bit). The
                    Port D output buffers have symmetrical drive characteristics with both high sink and source
                    capability. As inputs, Port D pins that are externally pulled low will source current if the pull-up
                    resistors are activated. The Port D pins are tri-stated when a reset condition becomes active,
                    even if the clock is not running.<br/>
                    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <!-- ad2 -->
                    <ins class="adsbygoogle"
                     style="display:inline-block;width:728px;height:90px"
                     data-ad-client="ca-pub-8795837294797076"
                     data-ad-slot="9256197016"></ins>
                    <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
              <br/><br/><b>RESET Reset input : </b>
              <br/> A low level on this pin for longer than the minimum pulse length will generate a
                    reset, even if the clock is not running.
              <br/><br/><b>AVCC : </b>
              <br/> AVCC is the supply voltage pin for the A/D Converter, Port C (3..0), and ADC (7..6). It should be
                    externally connected to VCC, even if the ADC is not used. If the ADC is used, it should be connected
                    to VCC through a low-pass filter. Note that Port C (5..4) use digital supply voltage, VCC.
              <br/><br/><b>AREF : </b>
              <br/> AREF is the analog reference pin for the A/D Converter.
              <br/><br/><b>ADC7..6 (TQFP and QFN/MLF Package Only) : </b>
              <br/>In the TQFP and QFN/MLF package, ADC7..6 serve as analog inputs to the A/D converter.
                    These pins are powered from the analog supply and serve as 10-bit ADC channels.
              <br/><br/><b>Architectural Overview</b>
              <br/>
              <img src="../../images/atmega8_arch.png"/>
              <br/>In order to maximize performance and parallelism, the AVR uses a Harvard architecture – with
                    separate memories and buses for program and data. Instructions in the Program memory are
                    executed with a single level pipelining. While one instruction is being executed, the next instruction
                    is pre-fetched from the Program memory. This concept enables instructions to be executed
                    in every clock cycle. The Program memory is In-System Reprogrammable Flash memory.<br/>
                    The fast-access Register File contains 32 × 8-bit general purpose working registers with a single
                    clock cycle access time. This allows single-cycle Arithmetic Logic Unit (ALU) operation. In a typical
                    ALU operation, two operands are output from the Register File, the operation is executed,
                    and the result is stored back in the Register File – in one clock cycle.<br/>
                    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <!-- ad2 -->
                    <ins class="adsbygoogle"
                     style="display:inline-block;width:728px;height:90px"
                     data-ad-client="ca-pub-8795837294797076"
                     data-ad-slot="9256197016"></ins>
                    <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                    <br/>
                    Six of the 32 registers can be used as three 16-bit indirect address register pointers for Data
                    Space addressing – enabling efficient address calculations. One of the these address pointers
                    can also be used as an address pointer for look up tables in Flash Program memory. These
                    added function registers are the 16-bit X-register, Y-register, and Z-register, described later in
                    this section.<br/><br/>
                    The ALU supports arithmetic and logic operations between registers or between a constant and
                    a register. Single register operations can also be executed in the ALU. After an arithmetic operation,
                    the Status Register is updated to reflect information about the result of the operation.
                    The Program flow is provided by conditional and unconditional jump and call instructions, able to
                    directly address the whole address space. Most AVR instructions have a single 16-bit word format.
                    Every Program memory address contains a 16-bit or 32-bit instruction.<br/>
                    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <!-- ad2 -->
                    <ins class="adsbygoogle"
                     style="display:inline-block;width:728px;height:90px"
                     data-ad-client="ca-pub-8795837294797076"
                     data-ad-slot="9256197016"></ins>
                    <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                    <br/>
                    Program Flash memory space is divided in two sections, the Boot program section and the
                    Application program section. Both sections have dedicated Lock Bits for write and read/write
                    protection. The SPM instruction that writes into the Application Flash memory section must
                    reside in the Boot program section.<br/><br/>
                    During interrupts and subroutine calls, the return address Program Counter (PC) is stored on the
                    Stack. The Stack is effectively allocated in the general data SRAM, and consequently the Stack
                    size is only limited by the total SRAM size and the usage of the SRAM. All user programs must
                    initialize the SP in the reset routine (before subroutines or interrupts are executed). The Stack
                    Pointer SP is read/write accessible in the I/O space. The data SRAM can easily be accessed
                    through the five different addressing modes supported in the AVR architecture.
                    <br/>
                    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <!-- ad2 -->
                    <ins class="adsbygoogle"
                     style="display:inline-block;width:728px;height:90px"
                     data-ad-client="ca-pub-8795837294797076"
                     data-ad-slot="9256197016"></ins>
                    <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                    <br/>
           </p>
         </div>
</div>

<div id="Soft" class="Container2">
     <div class="Container2-Header"> <p>ATmega8 - Software</p>  </div>
           <div class="Container2-text">
             <p class="C1p1">
                  <a style="color:#524141;" href="http://www.atmel.com/tools/atmelstudio.aspx">
                    ATmel Studio 4/5/6/7<br/><br/>
                    <img src="../../images/avr.png"/>
                  </a><br/><br/>
                  <a style="color:#524141;" href="https://sourceforge.net/projects/winavr/">
                    WinAvr (Compiler only)<br/><br/>
                    <img src="../../images/winavr.png"/>
                  </a>
              </p>
           </div>
</div>

<div id="Doc" class="Container2">
  <div class="Container2-Header"> <p>ATmega8 - Documents</p>  </div>
  <div class="Container2-text">
    <p class="C1p1">
         <a style="color:#524141;" href="http://www.atmel.com/Images/Atmel-2486-8-bit-AVR-microcontroller-ATmega8_L_datasheet.pdf">
           ATmega8 Datasheet <br/><br/>
         </a>
         <a style="color:#524141;" href="http://www.atmel.com/webdoc/">
           ATmel Tools Documentation <br/><br/>
         </a>
         <a style="color:#524141;" href="http://www.atmel.com/webdoc/avrlibcreferencemanual/">
          AVR Libc Reference Manual <br/><br/>
         </a>
         <a style="color:#524141;" href="http://winavr.sourceforge.net/WinAVR-user-manual.html">
          AVR Compiler Manual <br/><br/>
         </a>
     </p>
  </div>
</div>

<div id="Code" class="Container2">
<div class="Container2-Header"> <p>ATmega8 - Documents</p>  </div>
     <div class="Container2-text">
          <p class="C1p1">
            <!--         ****************************                   -->
           <b>LCD Interfacing </b><br/><br/>
           <iframe width="560" height="315" src="https://www.youtube.com/embed/f9U4FZ9njm8" frameborder="0" allowfullscreen></iframe>
           <br/>
           <a href="#">DownLoad Project</a>
           <hr/>
             <!--         ****************************                   -->
           <b>4 BIT LCD Interfacing</b><br/><br/>
           <iframe width="560" height="315" src="https://www.youtube.com/embed/IW_wTD62aQ4" frameborder="0" allowfullscreen></iframe>
           <br/>
           <a href="#">DownLoad Project </a>
           <hr/>
             <!--         ****************************                   -->
           <b>Custom Char on LCD</b><br/><br/>
           <iframe width="560" height="315" src="https://www.youtube.com/embed/6aXWhujd2vw" frameborder="0" allowfullscreen></iframe>
           <br/>
           <a href="#">DownLoad Project</a>
           <hr/>
           <!--         ****************************                   -->
           <b>Analog To Digital Convertor</b><br/><br/>
           <iframe width="560" height="315" src="https://www.youtube.com/embed/Psu_8SB7AmU" frameborder="0" allowfullscreen></iframe>
           <br/>
           <a href="#">DownLoad Project </a>
           <hr/>
           <!--         ****************************                   -->
           <b>I2C Programming</b><br/><br/>
           <iframe width="560" height="315" src="https://www.youtube.com/embed/Mx-srugCZgg" frameborder="0" allowfullscreen></iframe>
           <br/>
           <a href="#">DownLoad Project </a>
           <hr/>
           <!--         ****************************                   -->
         </p>

    </div>
</div>
<!-- ********************************************************* my Tempplate ****************************************-->
<!--
<div class="Container1">
  <div class="Container1-Header">  <p><a style="text-decoration: none; color: #fff;"href="../">Home</a></p>  </div>
   <div class="Container1-List">
    		<ul class="list1">
          <li><a  id="defaultOpen" class="tablinks" href="#" onClick="openCity(event,'Intro',this)">Introduction</a></li><br/>
        		<li><a id="tab2" class="tablinks" href="#" onClick="openCity(event,'Basic',this)">Basics</a></li><br/>
        		<li><a id="tab3" class="tablinks" href="#" onClick="openCity(event,'Soft',this)">Software</a></li><br/>
        		<li><a id="tab4" class="tablinks" href="#" onClick="openCity(event,'Doc',this)">Documents</a></li><br/>
        		<li><a id="tab5" class="tablinks"href="#" onClick="openCity(event,'Code',this)">Codes</a></li><br/>
    		</ul>
   </div>
</div>

<div id="Intro" class="Container2">
   <p>Basic</p>
</div>

<div id="Basic" class="Container2">
   <p>Basic</p>
</div>

<div id="Soft" class="Container2">
   <p>soft</p>
</div>
<div id="Doc" class="Container2">
 <p> DOC</p>
</div>

<div id="Code" class="Container2">
<p>Code</p>
</div>

-->
<!--<div id="Basic" class="Container2">
       <div class="Container2-Header"> <p>ATmega8 - Basics</p>  </div>
         <div class="Container2-text">
    		  <p class="C1p1"> <strong> Atmega8  Architecture</strong> <br/> <p>
          <p align="Left">This section discusses the Atmel®AVR core architecture in general. The main function of the
            CPU core is to ensure correct program execution. The CPU must therefore be able to accessmemories, perform calculations, control peripherals, and handle interrupts.</p>
          <img  src="../images/atmega8-arch0.png" align="right"/>

        </p>
        <strong> Atmega8  Block Diagram</strong> <br/>
        <p> The Atmel®AVR®
            ATmega8 is a low-power CMOS 8-bit microcontroller based on the AVR RISC
            architecture.
            By executing powerful instructions in a single clock cycle, the ATmega8 achieves
            throughputs approaching 1MIPS per MHz, allowing the system designer to optimize power con-
            sumption versus processing speed. </p>

         </p>
       <br/><br/>
       <p style="font-size:20px;">
  The ATmega8 provides the following features: 8 Kbytes of In-System Programmable Flash with
  Read-While-Write capabilities, 512 bytes of EEPROM, 1 Kbyte of SRAM, 23 general purpose
  I/O lines, 32 general purpose working registers,
  three flexible Timer/Counters with compare
  modes, internal and external interrupts, a seri
  al programmable USART, a byte oriented Two-
  wire Serial Interface, a 6-channel ADC (eight channels in TQFP and QFN/MLF packages) with
  10-bit accuracy, a programmable
  Watchdog Timer with Internal Os
  cillator, an SPI serial port,
  and five software selectable power saving modes. The Idle mode stops the CPU while allowing
  the SRAM, Timer/Counters, SPI port, and interr
  upt system to continue functioning.
       <img style="margin:20px 0px 0px 40%; " src="../images/atmega8-arch.png"  align="right" HSPACE="20" VSPACE="20"/>
        The Power-
down mode saves the register contents but freezes
the Oscillator, disabling all other chip func-
tions until the next Interrupt or Hardware Reset. In Power-save mode, the asynchronous timer
continues to run, allowing the user to maintain a timer base while the rest of the device is sleep-
ing. The ADC Noise Reduction mode stops the
CPU and all I/O modules except asynchronous
timer and ADC, to minimize switching noise
 during ADC conversions. In Standby mode, the
crystal/resonator Oscillator is running while the re
st of the device is sleeping. This allows very
fast start-up combined with low-power consumption.
       </p>
	</div>
</div>-->
<script>document.getElementById("defaultOpen").click();</script>
</body>
</html>
